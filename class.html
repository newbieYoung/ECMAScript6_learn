<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>class</title>
</head>
<body>
	<script type="text/javascript">
	'use strict';
	//实际只是一种语法糖
	{
		//不存在变量提升
		//console.log(new Point(1,2));
		class Point{
			constructor(x,y){
				this.x = x;
				this.y = y;
			}
		}
		var point = new Point(6,7);
		console.log(point);
		//继承
		class ColorPoint extends Point{
			constructor(x,y,color){
				//子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。
				//ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。
				super(x,y);
				//另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。
				this.color = color;
			}
		}
		var redPoint = new ColorPoint(1,2,'red');
		console.log(redPoint);
		//大多数浏览器的ES5实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。
	}
	</script>
</body>
</html>